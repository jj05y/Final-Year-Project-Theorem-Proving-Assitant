
options {
    MULTI = true;
    VISITOR = true;
    NODE_DEFAULT_VOID = true;
}

PARSER_BEGIN(Parser)
import java.util.Vector;

public class Parser{

    public static void main (String[] args) {
        
        Parser parser = new Parser(System.in);
            
        try {
            ASTBlock n = parser.Block();
            ParserVisitor v = new ParserDumpVisitor();
            DataPacket data = (DataPacket) n.jjtAccept(v, new DataPacket());
            data.dump();
            System.out.println("\nThanks a thousand.");
        } catch (Exception e) {
            System.out.println("Oops.");
            System.out.println(e.getMessage());
            e.printStackTrace();
        }
    }
}

PARSER_END(Parser)

TOKEN :
{
    <LBRACE: "{">
    |<RBRACE: "}">
    |<PLUS: "+">
    |<MINUS: "-">
    |<MULT: "*">
    |<INT: "int">
    |<BOOL: "bool">
    |<ID: (["a"-"z","A"-"Z"])+>
    |<LPAR: "(">
    |<RPAR: ")">
    |<NUM: (["0"-"9"])+>
    |<EQ: "=">
    |<GT: ">">
    |<LT: "<">
    |<ARROW: "->">
    |<COLON: ":">
    |<SEMI: ";">
    |<DEF: ":=">
    |<COMMA: ",">


}

SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
}

//Block ::= { Declset Stmtset }
ASTBlock Block() #Block :
{}
{
    <LBRACE> Declset() Stmtset() <RBRACE>
    {return jjtThis;}
}


//Declset ::= Decl Declset' 
void Declset() #void :
{}
{
    Decl() Declset_P()
}

//Declset' ::= Decl Declset' | EPSILON
void Declset_P() #void :
{}
{
    Decl() Declset_P()
    | {}
}



//Decl ::= int Vars ; | bool Vars ;
void Decl() #void : 
{}
{
    <INT> IntVars() <SEMI>
    | <BOOL> BoolVars() <SEMI>
}

//IntVars ::= id IntVars'
void IntVars() #IntVar :
{
    Token t;
}
{
    t=<ID> IntVars_P()
    {
        jjtThis.setName(t.image);
    }
}

//IntVars' ::= IntVars'' IntVars' | EPSILON
void IntVars_P() :
{}
{
    IntVars_P_P() IntVars_P()
    | {}
}

//IntVars'' ::= , id
void IntVars_P_P() #IntVar :
{
    Token t;
}
{
    <COMMA> t=<ID> 
    {
        jjtThis.setName(t.image);
    }
}


//BoolVars ::= id BoolVars'
void BoolVars() #BoolVar :
{
    Token t;
}
{
    t=<ID> BoolVars_P()
    {
        jjtThis.setName(t.image);
    }
}

//BoolVars' ::= BoolVars '' BoolVars' | EPSILON
void BoolVars_P() :
{}
{
    BoolVars_P_P() BoolVars_P()
    | {}
}

//BoolVars'' ::= , id
void BoolVars_P_P() #BoolVar :
{
    Token t;
}
{
    <COMMA> t=<ID>
    {
        jjtThis.setName(t.image);
    }
}

//Stmtset ::= Stmt Stmtset'
void Stmtset() :
{}
{
    Stmt() Stmtset_P()
}

//Stmtset' ::= ; Stmt Stmtset' | EPSILON
void Stmtset_P() : 
{}
{
    <SEMI> Stmt() Stmtset_P()
    | {}
    
}

//Stmt ::= Assn
void Stmt() :
{}
{
    Assn()
}

//Assn ::= id := Assn'
void Assn() #AssnResult :
{
    Token t;
}
{
    t=<ID> <DEF> Assn_P()
    {
        jjtThis.setName(t.image);
    }
}

//Assn' ::= Term Arith' Assn''
void Assn_P() :
{}
{
    Term() Arith_P() Assn_P_P()
}

//Assn'' ::=  Comp' Assn''' | EPSILON
void Assn_P_P() :
{}
{
    Comp_P() Assn_P_P_P()
    | {}
}

//Assn''' ::= -> Arith : Arith | EPSILON
void Assn_P_P_P()  :
{}
{
    Cond_P()
    | {}
}



//Arith ::= Term Arith' 
void Arith() : 
{}
{
    Term() Arith_P()
}


//Arith' ::= Arith'' | Arith''' | EPSILON
void Arith_P() :
{}
{
    Arith_Plus()
    | Arith_Minus()
    | {}
}

//Arith'' ::= + Term Arith'
void Arith_Plus() #AdditionResult :
{}
{
    <PLUS> Term() Arith_P() 
}

//Arith''' ::= - Term Arith'
void Arith_Minus() #SubtractionResult :
{}
{
    <MINUS> Term() Arith_P()
}

//Term ::= Factor Term'
void Term() :
{}
{
    Factor() Term_P()
}

//Term' ::= * Factor Term' | EPSILON
void Term_P() :
{}
{
    Term_P_P()
     | {}
}

void Term_P_P() #MultResult :
{}
{
    <MULT> Factor() Term_P()
}


//Factor ::= LitFactor | IdFactor | ( Arith )
void Factor() : 
{}
{
    <LPAR> Arith() <RPAR>
    | LitFactor()
    | IdFactor()
}

//LitFactor ::= num
void LitFactor() #LitFactor: 
{
    Token t;
}
{
    t=<NUM>
    {
        jjtThis.setValue(Integer.valueOf(t.image));
    }
}

//IdFactor ::= id
void IdFactor() #IdFactor : 
{
    Token t;
}
{
    t=<ID>
    {
        jjtThis.setName(t.image);
    }
}

//Comp ::= Arith Comp'
void Comp() :
{}
{
    Arith() Comp_P()
}

//Comp' ::= = Arith | > Arith | < Arith
void Comp_P() #Condition :
{
    Token t;
}
{
    (t=<EQ> Arith()
    | t=<GT> Arith()
    | t=<LT> Arith()
    )
    {
        jjtThis.setOperator(t.image);
    }
}


//I seem to have made this redundant
//Cond ::= Comp -> Arith : Arith
void Cond() : 
{}
{
    Comp() <ARROW> Arith() <COLON> Arith()
}


//need this tho
//Cond' ::= -> Arith : Arith
void Cond_P() #IfStatement :
{}
{
    <ARROW> Arith() <COLON> Arith()
}




